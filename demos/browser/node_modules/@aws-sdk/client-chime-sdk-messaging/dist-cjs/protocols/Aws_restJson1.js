"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeAws_restJson1CreateChannelCommand = exports.deserializeAws_restJson1ChannelFlowCallbackCommand = exports.deserializeAws_restJson1BatchCreateChannelMembershipCommand = exports.deserializeAws_restJson1AssociateChannelFlowCommand = exports.serializeAws_restJson1UpdateChannelReadMarkerCommand = exports.serializeAws_restJson1UpdateChannelMessageCommand = exports.serializeAws_restJson1UpdateChannelFlowCommand = exports.serializeAws_restJson1UpdateChannelCommand = exports.serializeAws_restJson1UntagResourceCommand = exports.serializeAws_restJson1TagResourceCommand = exports.serializeAws_restJson1SendChannelMessageCommand = exports.serializeAws_restJson1SearchChannelsCommand = exports.serializeAws_restJson1RedactChannelMessageCommand = exports.serializeAws_restJson1PutChannelMembershipPreferencesCommand = exports.serializeAws_restJson1ListTagsForResourceCommand = exports.serializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand = exports.serializeAws_restJson1ListChannelsAssociatedWithChannelFlowCommand = exports.serializeAws_restJson1ListChannelsCommand = exports.serializeAws_restJson1ListChannelModeratorsCommand = exports.serializeAws_restJson1ListChannelMessagesCommand = exports.serializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand = exports.serializeAws_restJson1ListChannelMembershipsCommand = exports.serializeAws_restJson1ListChannelFlowsCommand = exports.serializeAws_restJson1ListChannelBansCommand = exports.serializeAws_restJson1GetMessagingSessionEndpointCommand = exports.serializeAws_restJson1GetChannelMessageStatusCommand = exports.serializeAws_restJson1GetChannelMessageCommand = exports.serializeAws_restJson1GetChannelMembershipPreferencesCommand = exports.serializeAws_restJson1DisassociateChannelFlowCommand = exports.serializeAws_restJson1DescribeChannelModeratorCommand = exports.serializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand = exports.serializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand = exports.serializeAws_restJson1DescribeChannelMembershipCommand = exports.serializeAws_restJson1DescribeChannelFlowCommand = exports.serializeAws_restJson1DescribeChannelBanCommand = exports.serializeAws_restJson1DescribeChannelCommand = exports.serializeAws_restJson1DeleteChannelModeratorCommand = exports.serializeAws_restJson1DeleteChannelMessageCommand = exports.serializeAws_restJson1DeleteChannelMembershipCommand = exports.serializeAws_restJson1DeleteChannelFlowCommand = exports.serializeAws_restJson1DeleteChannelBanCommand = exports.serializeAws_restJson1DeleteChannelCommand = exports.serializeAws_restJson1CreateChannelModeratorCommand = exports.serializeAws_restJson1CreateChannelMembershipCommand = exports.serializeAws_restJson1CreateChannelFlowCommand = exports.serializeAws_restJson1CreateChannelBanCommand = exports.serializeAws_restJson1CreateChannelCommand = exports.serializeAws_restJson1ChannelFlowCallbackCommand = exports.serializeAws_restJson1BatchCreateChannelMembershipCommand = exports.serializeAws_restJson1AssociateChannelFlowCommand = void 0;
exports.deserializeAws_restJson1UpdateChannelReadMarkerCommand = exports.deserializeAws_restJson1UpdateChannelMessageCommand = exports.deserializeAws_restJson1UpdateChannelFlowCommand = exports.deserializeAws_restJson1UpdateChannelCommand = exports.deserializeAws_restJson1UntagResourceCommand = exports.deserializeAws_restJson1TagResourceCommand = exports.deserializeAws_restJson1SendChannelMessageCommand = exports.deserializeAws_restJson1SearchChannelsCommand = exports.deserializeAws_restJson1RedactChannelMessageCommand = exports.deserializeAws_restJson1PutChannelMembershipPreferencesCommand = exports.deserializeAws_restJson1ListTagsForResourceCommand = exports.deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand = exports.deserializeAws_restJson1ListChannelsAssociatedWithChannelFlowCommand = exports.deserializeAws_restJson1ListChannelsCommand = exports.deserializeAws_restJson1ListChannelModeratorsCommand = exports.deserializeAws_restJson1ListChannelMessagesCommand = exports.deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand = exports.deserializeAws_restJson1ListChannelMembershipsCommand = exports.deserializeAws_restJson1ListChannelFlowsCommand = exports.deserializeAws_restJson1ListChannelBansCommand = exports.deserializeAws_restJson1GetMessagingSessionEndpointCommand = exports.deserializeAws_restJson1GetChannelMessageStatusCommand = exports.deserializeAws_restJson1GetChannelMessageCommand = exports.deserializeAws_restJson1GetChannelMembershipPreferencesCommand = exports.deserializeAws_restJson1DisassociateChannelFlowCommand = exports.deserializeAws_restJson1DescribeChannelModeratorCommand = exports.deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand = exports.deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand = exports.deserializeAws_restJson1DescribeChannelMembershipCommand = exports.deserializeAws_restJson1DescribeChannelFlowCommand = exports.deserializeAws_restJson1DescribeChannelBanCommand = exports.deserializeAws_restJson1DescribeChannelCommand = exports.deserializeAws_restJson1DeleteChannelModeratorCommand = exports.deserializeAws_restJson1DeleteChannelMessageCommand = exports.deserializeAws_restJson1DeleteChannelMembershipCommand = exports.deserializeAws_restJson1DeleteChannelFlowCommand = exports.deserializeAws_restJson1DeleteChannelBanCommand = exports.deserializeAws_restJson1DeleteChannelCommand = exports.deserializeAws_restJson1CreateChannelModeratorCommand = exports.deserializeAws_restJson1CreateChannelMembershipCommand = exports.deserializeAws_restJson1CreateChannelFlowCommand = exports.deserializeAws_restJson1CreateChannelBanCommand = void 0;
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
const uuid_1 = require("uuid");
const ChimeSDKMessagingServiceException_1 = require("../models/ChimeSDKMessagingServiceException");
const models_0_1 = require("../models/models_0");
const serializeAws_restJson1AssociateChannelFlowCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/channel-flow";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    let body;
    body = JSON.stringify({
        ...(input.ChannelFlowArn != null && { ChannelFlowArn: input.ChannelFlowArn }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1AssociateChannelFlowCommand = serializeAws_restJson1AssociateChannelFlowCommand;
const serializeAws_restJson1BatchCreateChannelMembershipCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/memberships";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    const query = {
        operation: "batch-create",
    };
    let body;
    body = JSON.stringify({
        ...(input.MemberArns != null && { MemberArns: serializeAws_restJson1MemberArns(input.MemberArns, context) }),
        ...(input.Type != null && { Type: input.Type }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1BatchCreateChannelMembershipCommand = serializeAws_restJson1BatchCreateChannelMembershipCommand;
const serializeAws_restJson1ChannelFlowCallbackCommand = async (input, context) => {
    var _a;
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    const query = {
        operation: "channel-flow-callback",
    };
    let body;
    body = JSON.stringify({
        CallbackId: (_a = input.CallbackId) !== null && _a !== void 0 ? _a : (0, uuid_1.v4)(),
        ...(input.ChannelMessage != null && {
            ChannelMessage: serializeAws_restJson1ChannelMessageCallback(input.ChannelMessage, context),
        }),
        ...(input.DeleteResource != null && { DeleteResource: input.DeleteResource }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ChannelFlowCallbackCommand = serializeAws_restJson1ChannelFlowCallbackCommand;
const serializeAws_restJson1CreateChannelCommand = async (input, context) => {
    var _a;
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels";
    let body;
    body = JSON.stringify({
        ...(input.AppInstanceArn != null && { AppInstanceArn: input.AppInstanceArn }),
        ...(input.ChannelId != null && { ChannelId: input.ChannelId }),
        ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : (0, uuid_1.v4)(),
        ...(input.MemberArns != null && { MemberArns: serializeAws_restJson1ChannelMemberArns(input.MemberArns, context) }),
        ...(input.Metadata != null && { Metadata: input.Metadata }),
        ...(input.Mode != null && { Mode: input.Mode }),
        ...(input.ModeratorArns != null && {
            ModeratorArns: serializeAws_restJson1ChannelModeratorArns(input.ModeratorArns, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Privacy != null && { Privacy: input.Privacy }),
        ...(input.Tags != null && { Tags: serializeAws_restJson1TagList(input.Tags, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateChannelCommand = serializeAws_restJson1CreateChannelCommand;
const serializeAws_restJson1CreateChannelBanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/bans";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    let body;
    body = JSON.stringify({
        ...(input.MemberArn != null && { MemberArn: input.MemberArn }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateChannelBanCommand = serializeAws_restJson1CreateChannelBanCommand;
const serializeAws_restJson1CreateChannelFlowCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channel-flows";
    let body;
    body = JSON.stringify({
        ...(input.AppInstanceArn != null && { AppInstanceArn: input.AppInstanceArn }),
        ...(input.ClientRequestToken != null && { ClientRequestToken: input.ClientRequestToken }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Processors != null && { Processors: serializeAws_restJson1ProcessorList(input.Processors, context) }),
        ...(input.Tags != null && { Tags: serializeAws_restJson1TagList(input.Tags, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateChannelFlowCommand = serializeAws_restJson1CreateChannelFlowCommand;
const serializeAws_restJson1CreateChannelMembershipCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/memberships";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    let body;
    body = JSON.stringify({
        ...(input.MemberArn != null && { MemberArn: input.MemberArn }),
        ...(input.Type != null && { Type: input.Type }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateChannelMembershipCommand = serializeAws_restJson1CreateChannelMembershipCommand;
const serializeAws_restJson1CreateChannelModeratorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/moderators";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    let body;
    body = JSON.stringify({
        ...(input.ChannelModeratorArn != null && { ChannelModeratorArn: input.ChannelModeratorArn }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateChannelModeratorCommand = serializeAws_restJson1CreateChannelModeratorCommand;
const serializeAws_restJson1DeleteChannelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteChannelCommand = serializeAws_restJson1DeleteChannelCommand;
const serializeAws_restJson1DeleteChannelBanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/bans/{MemberArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MemberArn !== undefined) {
        const labelValue = input.MemberArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MemberArn.");
        }
        resolvedPath = resolvedPath.replace("{MemberArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MemberArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteChannelBanCommand = serializeAws_restJson1DeleteChannelBanCommand;
const serializeAws_restJson1DeleteChannelFlowCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channel-flows/{ChannelFlowArn}";
    if (input.ChannelFlowArn !== undefined) {
        const labelValue = input.ChannelFlowArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelFlowArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelFlowArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelFlowArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteChannelFlowCommand = serializeAws_restJson1DeleteChannelFlowCommand;
const serializeAws_restJson1DeleteChannelMembershipCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/memberships/{MemberArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MemberArn !== undefined) {
        const labelValue = input.MemberArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MemberArn.");
        }
        resolvedPath = resolvedPath.replace("{MemberArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MemberArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteChannelMembershipCommand = serializeAws_restJson1DeleteChannelMembershipCommand;
const serializeAws_restJson1DeleteChannelMessageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/messages/{MessageId}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MessageId !== undefined) {
        const labelValue = input.MessageId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MessageId.");
        }
        resolvedPath = resolvedPath.replace("{MessageId}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MessageId.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteChannelMessageCommand = serializeAws_restJson1DeleteChannelMessageCommand;
const serializeAws_restJson1DeleteChannelModeratorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/moderators/{ChannelModeratorArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.ChannelModeratorArn !== undefined) {
        const labelValue = input.ChannelModeratorArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelModeratorArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelModeratorArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelModeratorArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteChannelModeratorCommand = serializeAws_restJson1DeleteChannelModeratorCommand;
const serializeAws_restJson1DescribeChannelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeChannelCommand = serializeAws_restJson1DescribeChannelCommand;
const serializeAws_restJson1DescribeChannelBanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/bans/{MemberArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MemberArn !== undefined) {
        const labelValue = input.MemberArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MemberArn.");
        }
        resolvedPath = resolvedPath.replace("{MemberArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MemberArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeChannelBanCommand = serializeAws_restJson1DescribeChannelBanCommand;
const serializeAws_restJson1DescribeChannelFlowCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channel-flows/{ChannelFlowArn}";
    if (input.ChannelFlowArn !== undefined) {
        const labelValue = input.ChannelFlowArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelFlowArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelFlowArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelFlowArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeChannelFlowCommand = serializeAws_restJson1DescribeChannelFlowCommand;
const serializeAws_restJson1DescribeChannelMembershipCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/memberships/{MemberArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MemberArn !== undefined) {
        const labelValue = input.MemberArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MemberArn.");
        }
        resolvedPath = resolvedPath.replace("{MemberArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MemberArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeChannelMembershipCommand = serializeAws_restJson1DescribeChannelMembershipCommand;
const serializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    const query = {
        scope: "app-instance-user-membership",
        ...(input.AppInstanceUserArn !== undefined && { "app-instance-user-arn": input.AppInstanceUserArn }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand = serializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand;
const serializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    const query = {
        scope: "app-instance-user-moderated-channel",
        ...(input.AppInstanceUserArn !== undefined && { "app-instance-user-arn": input.AppInstanceUserArn }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand = serializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand;
const serializeAws_restJson1DescribeChannelModeratorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/moderators/{ChannelModeratorArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.ChannelModeratorArn !== undefined) {
        const labelValue = input.ChannelModeratorArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelModeratorArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelModeratorArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelModeratorArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeChannelModeratorCommand = serializeAws_restJson1DescribeChannelModeratorCommand;
const serializeAws_restJson1DisassociateChannelFlowCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/channel-flow/{ChannelFlowArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.ChannelFlowArn !== undefined) {
        const labelValue = input.ChannelFlowArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelFlowArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelFlowArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelFlowArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DisassociateChannelFlowCommand = serializeAws_restJson1DisassociateChannelFlowCommand;
const serializeAws_restJson1GetChannelMembershipPreferencesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/memberships/{MemberArn}/preferences";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MemberArn !== undefined) {
        const labelValue = input.MemberArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MemberArn.");
        }
        resolvedPath = resolvedPath.replace("{MemberArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MemberArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetChannelMembershipPreferencesCommand = serializeAws_restJson1GetChannelMembershipPreferencesCommand;
const serializeAws_restJson1GetChannelMessageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/messages/{MessageId}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MessageId !== undefined) {
        const labelValue = input.MessageId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MessageId.");
        }
        resolvedPath = resolvedPath.replace("{MessageId}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MessageId.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetChannelMessageCommand = serializeAws_restJson1GetChannelMessageCommand;
const serializeAws_restJson1GetChannelMessageStatusCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/messages/{MessageId}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MessageId !== undefined) {
        const labelValue = input.MessageId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MessageId.");
        }
        resolvedPath = resolvedPath.replace("{MessageId}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MessageId.");
    }
    const query = {
        scope: "message-status",
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1GetChannelMessageStatusCommand = serializeAws_restJson1GetChannelMessageStatusCommand;
const serializeAws_restJson1GetMessagingSessionEndpointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/endpoints/messaging-session";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetMessagingSessionEndpointCommand = serializeAws_restJson1GetMessagingSessionEndpointCommand;
const serializeAws_restJson1ListChannelBansCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/bans";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    const query = {
        ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
        ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListChannelBansCommand = serializeAws_restJson1ListChannelBansCommand;
const serializeAws_restJson1ListChannelFlowsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channel-flows";
    const query = {
        ...(input.AppInstanceArn !== undefined && { "app-instance-arn": input.AppInstanceArn }),
        ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
        ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListChannelFlowsCommand = serializeAws_restJson1ListChannelFlowsCommand;
const serializeAws_restJson1ListChannelMembershipsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/memberships";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    const query = {
        ...(input.Type !== undefined && { type: input.Type }),
        ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
        ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListChannelMembershipsCommand = serializeAws_restJson1ListChannelMembershipsCommand;
const serializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels";
    const query = {
        scope: "app-instance-user-memberships",
        ...(input.AppInstanceUserArn !== undefined && { "app-instance-user-arn": input.AppInstanceUserArn }),
        ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
        ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand = serializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand;
const serializeAws_restJson1ListChannelMessagesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/messages";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    const query = {
        ...(input.SortOrder !== undefined && { "sort-order": input.SortOrder }),
        ...(input.NotBefore !== undefined && {
            "not-before": (input.NotBefore.toISOString().split(".")[0] + "Z").toString(),
        }),
        ...(input.NotAfter !== undefined && { "not-after": (input.NotAfter.toISOString().split(".")[0] + "Z").toString() }),
        ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
        ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListChannelMessagesCommand = serializeAws_restJson1ListChannelMessagesCommand;
const serializeAws_restJson1ListChannelModeratorsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/moderators";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    const query = {
        ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
        ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListChannelModeratorsCommand = serializeAws_restJson1ListChannelModeratorsCommand;
const serializeAws_restJson1ListChannelsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels";
    const query = {
        ...(input.AppInstanceArn !== undefined && { "app-instance-arn": input.AppInstanceArn }),
        ...(input.Privacy !== undefined && { privacy: input.Privacy }),
        ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
        ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListChannelsCommand = serializeAws_restJson1ListChannelsCommand;
const serializeAws_restJson1ListChannelsAssociatedWithChannelFlowCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels";
    const query = {
        scope: "channel-flow-associations",
        ...(input.ChannelFlowArn !== undefined && { "channel-flow-arn": input.ChannelFlowArn }),
        ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
        ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListChannelsAssociatedWithChannelFlowCommand = serializeAws_restJson1ListChannelsAssociatedWithChannelFlowCommand;
const serializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels";
    const query = {
        scope: "app-instance-user-moderated-channels",
        ...(input.AppInstanceUserArn !== undefined && { "app-instance-user-arn": input.AppInstanceUserArn }),
        ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
        ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand = serializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand;
const serializeAws_restJson1ListTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/tags";
    const query = {
        ...(input.ResourceARN !== undefined && { arn: input.ResourceARN }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListTagsForResourceCommand = serializeAws_restJson1ListTagsForResourceCommand;
const serializeAws_restJson1PutChannelMembershipPreferencesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/memberships/{MemberArn}/preferences";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MemberArn !== undefined) {
        const labelValue = input.MemberArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MemberArn.");
        }
        resolvedPath = resolvedPath.replace("{MemberArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MemberArn.");
    }
    let body;
    body = JSON.stringify({
        ...(input.Preferences != null && {
            Preferences: serializeAws_restJson1ChannelMembershipPreferences(input.Preferences, context),
        }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1PutChannelMembershipPreferencesCommand = serializeAws_restJson1PutChannelMembershipPreferencesCommand;
const serializeAws_restJson1RedactChannelMessageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/messages/{MessageId}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MessageId !== undefined) {
        const labelValue = input.MessageId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MessageId.");
        }
        resolvedPath = resolvedPath.replace("{MessageId}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MessageId.");
    }
    const query = {
        operation: "redact",
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1RedactChannelMessageCommand = serializeAws_restJson1RedactChannelMessageCommand;
const serializeAws_restJson1SearchChannelsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels";
    const query = {
        operation: "search",
        ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
        ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    };
    let body;
    body = JSON.stringify({
        ...(input.Fields != null && { Fields: serializeAws_restJson1SearchFields(input.Fields, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1SearchChannelsCommand = serializeAws_restJson1SearchChannelsCommand;
const serializeAws_restJson1SendChannelMessageCommand = async (input, context) => {
    var _a;
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/messages";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    let body;
    body = JSON.stringify({
        ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : (0, uuid_1.v4)(),
        ...(input.Content != null && { Content: input.Content }),
        ...(input.MessageAttributes != null && {
            MessageAttributes: serializeAws_restJson1MessageAttributeMap(input.MessageAttributes, context),
        }),
        ...(input.Metadata != null && { Metadata: input.Metadata }),
        ...(input.Persistence != null && { Persistence: input.Persistence }),
        ...(input.PushNotification != null && {
            PushNotification: serializeAws_restJson1PushNotificationConfiguration(input.PushNotification, context),
        }),
        ...(input.Type != null && { Type: input.Type }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1SendChannelMessageCommand = serializeAws_restJson1SendChannelMessageCommand;
const serializeAws_restJson1TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/tags";
    const query = {
        operation: "tag-resource",
    };
    let body;
    body = JSON.stringify({
        ...(input.ResourceARN != null && { ResourceARN: input.ResourceARN }),
        ...(input.Tags != null && { Tags: serializeAws_restJson1TagList(input.Tags, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1TagResourceCommand = serializeAws_restJson1TagResourceCommand;
const serializeAws_restJson1UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/tags";
    const query = {
        operation: "untag-resource",
    };
    let body;
    body = JSON.stringify({
        ...(input.ResourceARN != null && { ResourceARN: input.ResourceARN }),
        ...(input.TagKeys != null && { TagKeys: serializeAws_restJson1TagKeyList(input.TagKeys, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1UntagResourceCommand = serializeAws_restJson1UntagResourceCommand;
const serializeAws_restJson1UpdateChannelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    let body;
    body = JSON.stringify({
        ...(input.Metadata != null && { Metadata: input.Metadata }),
        ...(input.Mode != null && { Mode: input.Mode }),
        ...(input.Name != null && { Name: input.Name }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateChannelCommand = serializeAws_restJson1UpdateChannelCommand;
const serializeAws_restJson1UpdateChannelFlowCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channel-flows/{ChannelFlowArn}";
    if (input.ChannelFlowArn !== undefined) {
        const labelValue = input.ChannelFlowArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelFlowArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelFlowArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelFlowArn.");
    }
    let body;
    body = JSON.stringify({
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Processors != null && { Processors: serializeAws_restJson1ProcessorList(input.Processors, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateChannelFlowCommand = serializeAws_restJson1UpdateChannelFlowCommand;
const serializeAws_restJson1UpdateChannelMessageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` +
        "/channels/{ChannelArn}/messages/{MessageId}";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    if (input.MessageId !== undefined) {
        const labelValue = input.MessageId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: MessageId.");
        }
        resolvedPath = resolvedPath.replace("{MessageId}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: MessageId.");
    }
    let body;
    body = JSON.stringify({
        ...(input.Content != null && { Content: input.Content }),
        ...(input.Metadata != null && { Metadata: input.Metadata }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateChannelMessageCommand = serializeAws_restJson1UpdateChannelMessageCommand;
const serializeAws_restJson1UpdateChannelReadMarkerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
    };
    let resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/channels/{ChannelArn}/readMarker";
    if (input.ChannelArn !== undefined) {
        const labelValue = input.ChannelArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ChannelArn.");
        }
        resolvedPath = resolvedPath.replace("{ChannelArn}", (0, smithy_client_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ChannelArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateChannelReadMarkerCommand = serializeAws_restJson1UpdateChannelReadMarkerCommand;
const deserializeAws_restJson1AssociateChannelFlowCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AssociateChannelFlowCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AssociateChannelFlowCommand = deserializeAws_restJson1AssociateChannelFlowCommand;
const deserializeAws_restJson1AssociateChannelFlowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.chimesdkmessaging#NotFoundException":
            throw await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1BatchCreateChannelMembershipCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1BatchCreateChannelMembershipCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        BatchChannelMemberships: undefined,
        Errors: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.BatchChannelMemberships !== undefined && data.BatchChannelMemberships !== null) {
        contents.BatchChannelMemberships = deserializeAws_restJson1BatchChannelMemberships(data.BatchChannelMemberships, context);
    }
    if (data.Errors !== undefined && data.Errors !== null) {
        contents.Errors = deserializeAws_restJson1BatchCreateChannelMembershipErrors(data.Errors, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1BatchCreateChannelMembershipCommand = deserializeAws_restJson1BatchCreateChannelMembershipCommand;
const deserializeAws_restJson1BatchCreateChannelMembershipCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ChannelFlowCallbackCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ChannelFlowCallbackCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        CallbackId: undefined,
        ChannelArn: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.CallbackId !== undefined && data.CallbackId !== null) {
        contents.CallbackId = (0, smithy_client_1.expectString)(data.CallbackId);
    }
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ChannelFlowCallbackCommand = deserializeAws_restJson1ChannelFlowCallbackCommand;
const deserializeAws_restJson1ChannelFlowCallbackCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1CreateChannelCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateChannelCommand = deserializeAws_restJson1CreateChannelCommand;
const deserializeAws_restJson1CreateChannelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.chimesdkmessaging#ResourceLimitExceededException":
            throw await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1CreateChannelBanCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateChannelBanCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        Member: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.Member !== undefined && data.Member !== null) {
        contents.Member = deserializeAws_restJson1Identity(data.Member, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateChannelBanCommand = deserializeAws_restJson1CreateChannelBanCommand;
const deserializeAws_restJson1CreateChannelBanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.chimesdkmessaging#ResourceLimitExceededException":
            throw await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1CreateChannelFlowCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateChannelFlowCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelFlowArn: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelFlowArn !== undefined && data.ChannelFlowArn !== null) {
        contents.ChannelFlowArn = (0, smithy_client_1.expectString)(data.ChannelFlowArn);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateChannelFlowCommand = deserializeAws_restJson1CreateChannelFlowCommand;
const deserializeAws_restJson1CreateChannelFlowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.chimesdkmessaging#ResourceLimitExceededException":
            throw await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1CreateChannelMembershipCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateChannelMembershipCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        Member: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.Member !== undefined && data.Member !== null) {
        contents.Member = deserializeAws_restJson1Identity(data.Member, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateChannelMembershipCommand = deserializeAws_restJson1CreateChannelMembershipCommand;
const deserializeAws_restJson1CreateChannelMembershipCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.chimesdkmessaging#ResourceLimitExceededException":
            throw await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1CreateChannelModeratorCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateChannelModeratorCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        ChannelModerator: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.ChannelModerator !== undefined && data.ChannelModerator !== null) {
        contents.ChannelModerator = deserializeAws_restJson1Identity(data.ChannelModerator, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateChannelModeratorCommand = deserializeAws_restJson1CreateChannelModeratorCommand;
const deserializeAws_restJson1CreateChannelModeratorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.chimesdkmessaging#ResourceLimitExceededException":
            throw await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeleteChannelCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelCommand = deserializeAws_restJson1DeleteChannelCommand;
const deserializeAws_restJson1DeleteChannelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeleteChannelBanCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteChannelBanCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelBanCommand = deserializeAws_restJson1DeleteChannelBanCommand;
const deserializeAws_restJson1DeleteChannelBanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeleteChannelFlowCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteChannelFlowCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelFlowCommand = deserializeAws_restJson1DeleteChannelFlowCommand;
const deserializeAws_restJson1DeleteChannelFlowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeleteChannelMembershipCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteChannelMembershipCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelMembershipCommand = deserializeAws_restJson1DeleteChannelMembershipCommand;
const deserializeAws_restJson1DeleteChannelMembershipCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeleteChannelMessageCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteChannelMessageCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelMessageCommand = deserializeAws_restJson1DeleteChannelMessageCommand;
const deserializeAws_restJson1DeleteChannelMessageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeleteChannelModeratorCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteChannelModeratorCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelModeratorCommand = deserializeAws_restJson1DeleteChannelModeratorCommand;
const deserializeAws_restJson1DeleteChannelModeratorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribeChannelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        Channel: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Channel !== undefined && data.Channel !== null) {
        contents.Channel = deserializeAws_restJson1Channel(data.Channel, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelCommand = deserializeAws_restJson1DescribeChannelCommand;
const deserializeAws_restJson1DescribeChannelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribeChannelBanCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeChannelBanCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelBan: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelBan !== undefined && data.ChannelBan !== null) {
        contents.ChannelBan = deserializeAws_restJson1ChannelBan(data.ChannelBan, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelBanCommand = deserializeAws_restJson1DescribeChannelBanCommand;
const deserializeAws_restJson1DescribeChannelBanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.chimesdkmessaging#NotFoundException":
            throw await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribeChannelFlowCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeChannelFlowCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelFlow: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelFlow !== undefined && data.ChannelFlow !== null) {
        contents.ChannelFlow = deserializeAws_restJson1ChannelFlow(data.ChannelFlow, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelFlowCommand = deserializeAws_restJson1DescribeChannelFlowCommand;
const deserializeAws_restJson1DescribeChannelFlowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribeChannelMembershipCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeChannelMembershipCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelMembership: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelMembership !== undefined && data.ChannelMembership !== null) {
        contents.ChannelMembership = deserializeAws_restJson1ChannelMembership(data.ChannelMembership, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelMembershipCommand = deserializeAws_restJson1DescribeChannelMembershipCommand;
const deserializeAws_restJson1DescribeChannelMembershipCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.chimesdkmessaging#NotFoundException":
            throw await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelMembership: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelMembership !== undefined && data.ChannelMembership !== null) {
        contents.ChannelMembership = deserializeAws_restJson1ChannelMembershipForAppInstanceUserSummary(data.ChannelMembership, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand = deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand;
const deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        Channel: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Channel !== undefined && data.Channel !== null) {
        contents.Channel = deserializeAws_restJson1ChannelModeratedByAppInstanceUserSummary(data.Channel, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand = deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand;
const deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribeChannelModeratorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeChannelModeratorCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelModerator: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelModerator !== undefined && data.ChannelModerator !== null) {
        contents.ChannelModerator = deserializeAws_restJson1ChannelModerator(data.ChannelModerator, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelModeratorCommand = deserializeAws_restJson1DescribeChannelModeratorCommand;
const deserializeAws_restJson1DescribeChannelModeratorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.chimesdkmessaging#NotFoundException":
            throw await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DisassociateChannelFlowCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restJson1DisassociateChannelFlowCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DisassociateChannelFlowCommand = deserializeAws_restJson1DisassociateChannelFlowCommand;
const deserializeAws_restJson1DisassociateChannelFlowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.chimesdkmessaging#NotFoundException":
            throw await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1GetChannelMembershipPreferencesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetChannelMembershipPreferencesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        Member: undefined,
        Preferences: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.Member !== undefined && data.Member !== null) {
        contents.Member = deserializeAws_restJson1Identity(data.Member, context);
    }
    if (data.Preferences !== undefined && data.Preferences !== null) {
        contents.Preferences = deserializeAws_restJson1ChannelMembershipPreferences(data.Preferences, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetChannelMembershipPreferencesCommand = deserializeAws_restJson1GetChannelMembershipPreferencesCommand;
const deserializeAws_restJson1GetChannelMembershipPreferencesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1GetChannelMessageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetChannelMessageCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelMessage: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelMessage !== undefined && data.ChannelMessage !== null) {
        contents.ChannelMessage = deserializeAws_restJson1ChannelMessage(data.ChannelMessage, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetChannelMessageCommand = deserializeAws_restJson1GetChannelMessageCommand;
const deserializeAws_restJson1GetChannelMessageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.chimesdkmessaging#NotFoundException":
            throw await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1GetChannelMessageStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetChannelMessageStatusCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        Status: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Status !== undefined && data.Status !== null) {
        contents.Status = deserializeAws_restJson1ChannelMessageStatusStructure(data.Status, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetChannelMessageStatusCommand = deserializeAws_restJson1GetChannelMessageStatusCommand;
const deserializeAws_restJson1GetChannelMessageStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1GetMessagingSessionEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetMessagingSessionEndpointCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        Endpoint: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Endpoint !== undefined && data.Endpoint !== null) {
        contents.Endpoint = deserializeAws_restJson1MessagingSessionEndpoint(data.Endpoint, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetMessagingSessionEndpointCommand = deserializeAws_restJson1GetMessagingSessionEndpointCommand;
const deserializeAws_restJson1GetMessagingSessionEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListChannelBansCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListChannelBansCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        ChannelBans: undefined,
        NextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.ChannelBans !== undefined && data.ChannelBans !== null) {
        contents.ChannelBans = deserializeAws_restJson1ChannelBanSummaryList(data.ChannelBans, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = (0, smithy_client_1.expectString)(data.NextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelBansCommand = deserializeAws_restJson1ListChannelBansCommand;
const deserializeAws_restJson1ListChannelBansCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListChannelFlowsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListChannelFlowsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelFlows: undefined,
        NextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelFlows !== undefined && data.ChannelFlows !== null) {
        contents.ChannelFlows = deserializeAws_restJson1ChannelFlowSummaryList(data.ChannelFlows, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = (0, smithy_client_1.expectString)(data.NextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelFlowsCommand = deserializeAws_restJson1ListChannelFlowsCommand;
const deserializeAws_restJson1ListChannelFlowsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListChannelMembershipsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListChannelMembershipsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        ChannelMemberships: undefined,
        NextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.ChannelMemberships !== undefined && data.ChannelMemberships !== null) {
        contents.ChannelMemberships = deserializeAws_restJson1ChannelMembershipSummaryList(data.ChannelMemberships, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = (0, smithy_client_1.expectString)(data.NextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelMembershipsCommand = deserializeAws_restJson1ListChannelMembershipsCommand;
const deserializeAws_restJson1ListChannelMembershipsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelMemberships: undefined,
        NextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelMemberships !== undefined && data.ChannelMemberships !== null) {
        contents.ChannelMemberships = deserializeAws_restJson1ChannelMembershipForAppInstanceUserSummaryList(data.ChannelMemberships, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = (0, smithy_client_1.expectString)(data.NextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand = deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand;
const deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListChannelMessagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListChannelMessagesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        ChannelMessages: undefined,
        NextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.ChannelMessages !== undefined && data.ChannelMessages !== null) {
        contents.ChannelMessages = deserializeAws_restJson1ChannelMessageSummaryList(data.ChannelMessages, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = (0, smithy_client_1.expectString)(data.NextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelMessagesCommand = deserializeAws_restJson1ListChannelMessagesCommand;
const deserializeAws_restJson1ListChannelMessagesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListChannelModeratorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListChannelModeratorsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        ChannelModerators: undefined,
        NextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.ChannelModerators !== undefined && data.ChannelModerators !== null) {
        contents.ChannelModerators = deserializeAws_restJson1ChannelModeratorSummaryList(data.ChannelModerators, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = (0, smithy_client_1.expectString)(data.NextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelModeratorsCommand = deserializeAws_restJson1ListChannelModeratorsCommand;
const deserializeAws_restJson1ListChannelModeratorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListChannelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListChannelsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        Channels: undefined,
        NextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Channels !== undefined && data.Channels !== null) {
        contents.Channels = deserializeAws_restJson1ChannelSummaryList(data.Channels, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = (0, smithy_client_1.expectString)(data.NextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelsCommand = deserializeAws_restJson1ListChannelsCommand;
const deserializeAws_restJson1ListChannelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListChannelsAssociatedWithChannelFlowCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListChannelsAssociatedWithChannelFlowCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        Channels: undefined,
        NextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Channels !== undefined && data.Channels !== null) {
        contents.Channels = deserializeAws_restJson1ChannelAssociatedWithFlowSummaryList(data.Channels, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = (0, smithy_client_1.expectString)(data.NextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelsAssociatedWithChannelFlowCommand = deserializeAws_restJson1ListChannelsAssociatedWithChannelFlowCommand;
const deserializeAws_restJson1ListChannelsAssociatedWithChannelFlowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        Channels: undefined,
        NextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Channels !== undefined && data.Channels !== null) {
        contents.Channels = deserializeAws_restJson1ChannelModeratedByAppInstanceUserSummaryList(data.Channels, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = (0, smithy_client_1.expectString)(data.NextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand = deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand;
const deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTagsForResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        Tags: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Tags !== undefined && data.Tags !== null) {
        contents.Tags = deserializeAws_restJson1TagList(data.Tags, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListTagsForResourceCommand = deserializeAws_restJson1ListTagsForResourceCommand;
const deserializeAws_restJson1ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1PutChannelMembershipPreferencesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1PutChannelMembershipPreferencesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        Member: undefined,
        Preferences: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.Member !== undefined && data.Member !== null) {
        contents.Member = deserializeAws_restJson1Identity(data.Member, context);
    }
    if (data.Preferences !== undefined && data.Preferences !== null) {
        contents.Preferences = deserializeAws_restJson1ChannelMembershipPreferences(data.Preferences, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutChannelMembershipPreferencesCommand = deserializeAws_restJson1PutChannelMembershipPreferencesCommand;
const deserializeAws_restJson1PutChannelMembershipPreferencesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1RedactChannelMessageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RedactChannelMessageCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        MessageId: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.MessageId !== undefined && data.MessageId !== null) {
        contents.MessageId = (0, smithy_client_1.expectString)(data.MessageId);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RedactChannelMessageCommand = deserializeAws_restJson1RedactChannelMessageCommand;
const deserializeAws_restJson1RedactChannelMessageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1SearchChannelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SearchChannelsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        Channels: undefined,
        NextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Channels !== undefined && data.Channels !== null) {
        contents.Channels = deserializeAws_restJson1ChannelSummaryList(data.Channels, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = (0, smithy_client_1.expectString)(data.NextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1SearchChannelsCommand = deserializeAws_restJson1SearchChannelsCommand;
const deserializeAws_restJson1SearchChannelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1SendChannelMessageCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restJson1SendChannelMessageCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        MessageId: undefined,
        Status: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.MessageId !== undefined && data.MessageId !== null) {
        contents.MessageId = (0, smithy_client_1.expectString)(data.MessageId);
    }
    if (data.Status !== undefined && data.Status !== null) {
        contents.Status = deserializeAws_restJson1ChannelMessageStatusStructure(data.Status, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1SendChannelMessageCommand = deserializeAws_restJson1SendChannelMessageCommand;
const deserializeAws_restJson1SendChannelMessageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restJson1TagResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1TagResourceCommand = deserializeAws_restJson1TagResourceCommand;
const deserializeAws_restJson1TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.chimesdkmessaging#ResourceLimitExceededException":
            throw await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restJson1UntagResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UntagResourceCommand = deserializeAws_restJson1UntagResourceCommand;
const deserializeAws_restJson1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1UpdateChannelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateChannelCommand = deserializeAws_restJson1UpdateChannelCommand;
const deserializeAws_restJson1UpdateChannelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1UpdateChannelFlowCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateChannelFlowCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelFlowArn: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelFlowArn !== undefined && data.ChannelFlowArn !== null) {
        contents.ChannelFlowArn = (0, smithy_client_1.expectString)(data.ChannelFlowArn);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateChannelFlowCommand = deserializeAws_restJson1UpdateChannelFlowCommand;
const deserializeAws_restJson1UpdateChannelFlowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1UpdateChannelMessageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateChannelMessageCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
        MessageId: undefined,
        Status: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    if (data.MessageId !== undefined && data.MessageId !== null) {
        contents.MessageId = (0, smithy_client_1.expectString)(data.MessageId);
    }
    if (data.Status !== undefined && data.Status !== null) {
        contents.Status = deserializeAws_restJson1ChannelMessageStatusStructure(data.Status, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateChannelMessageCommand = deserializeAws_restJson1UpdateChannelMessageCommand;
const deserializeAws_restJson1UpdateChannelMessageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1UpdateChannelReadMarkerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateChannelReadMarkerCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        ChannelArn: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
        contents.ChannelArn = (0, smithy_client_1.expectString)(data.ChannelArn);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateChannelReadMarkerCommand = deserializeAws_restJson1UpdateChannelReadMarkerCommand;
const deserializeAws_restJson1UpdateChannelReadMarkerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmessaging#BadRequestException":
            throw await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmessaging#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmessaging#ForbiddenException":
            throw await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmessaging#ServiceFailureException":
            throw await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmessaging#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmessaging#ThrottledClientException":
            throw await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmessaging#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new ChimeSDKMessagingServiceException_1.ChimeSDKMessagingServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1BadRequestExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.Code !== undefined && data.Code !== null) {
        contents.Code = (0, smithy_client_1.expectString)(data.Code);
    }
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = (0, smithy_client_1.expectString)(data.Message);
    }
    const exception = new models_0_1.BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.Code !== undefined && data.Code !== null) {
        contents.Code = (0, smithy_client_1.expectString)(data.Code);
    }
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = (0, smithy_client_1.expectString)(data.Message);
    }
    const exception = new models_0_1.ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ForbiddenExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.Code !== undefined && data.Code !== null) {
        contents.Code = (0, smithy_client_1.expectString)(data.Code);
    }
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = (0, smithy_client_1.expectString)(data.Message);
    }
    const exception = new models_0_1.ForbiddenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1NotFoundExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.Code !== undefined && data.Code !== null) {
        contents.Code = (0, smithy_client_1.expectString)(data.Code);
    }
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = (0, smithy_client_1.expectString)(data.Message);
    }
    const exception = new models_0_1.NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ResourceLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.Code !== undefined && data.Code !== null) {
        contents.Code = (0, smithy_client_1.expectString)(data.Code);
    }
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = (0, smithy_client_1.expectString)(data.Message);
    }
    const exception = new models_0_1.ResourceLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ServiceFailureExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.Code !== undefined && data.Code !== null) {
        contents.Code = (0, smithy_client_1.expectString)(data.Code);
    }
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = (0, smithy_client_1.expectString)(data.Message);
    }
    const exception = new models_0_1.ServiceFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ServiceUnavailableExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.Code !== undefined && data.Code !== null) {
        contents.Code = (0, smithy_client_1.expectString)(data.Code);
    }
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = (0, smithy_client_1.expectString)(data.Message);
    }
    const exception = new models_0_1.ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ThrottledClientExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.Code !== undefined && data.Code !== null) {
        contents.Code = (0, smithy_client_1.expectString)(data.Code);
    }
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = (0, smithy_client_1.expectString)(data.Message);
    }
    const exception = new models_0_1.ThrottledClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1UnauthorizedClientExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.Code !== undefined && data.Code !== null) {
        contents.Code = (0, smithy_client_1.expectString)(data.Code);
    }
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = (0, smithy_client_1.expectString)(data.Message);
    }
    const exception = new models_0_1.UnauthorizedClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const serializeAws_restJson1ChannelMemberArns = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1ChannelMembershipPreferences = (input, context) => {
    return {
        ...(input.PushNotifications != null && {
            PushNotifications: serializeAws_restJson1PushNotificationPreferences(input.PushNotifications, context),
        }),
    };
};
const serializeAws_restJson1ChannelMessageCallback = (input, context) => {
    return {
        ...(input.Content != null && { Content: input.Content }),
        ...(input.MessageAttributes != null && {
            MessageAttributes: serializeAws_restJson1MessageAttributeMap(input.MessageAttributes, context),
        }),
        ...(input.MessageId != null && { MessageId: input.MessageId }),
        ...(input.Metadata != null && { Metadata: input.Metadata }),
        ...(input.PushNotification != null && {
            PushNotification: serializeAws_restJson1PushNotificationConfiguration(input.PushNotification, context),
        }),
    };
};
const serializeAws_restJson1ChannelModeratorArns = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1LambdaConfiguration = (input, context) => {
    return {
        ...(input.InvocationType != null && { InvocationType: input.InvocationType }),
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    };
};
const serializeAws_restJson1MemberArns = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1MessageAttributeMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: serializeAws_restJson1MessageAttributeValue(value, context),
        };
    }, {});
};
const serializeAws_restJson1MessageAttributeStringValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1MessageAttributeValue = (input, context) => {
    return {
        ...(input.StringValues != null && {
            StringValues: serializeAws_restJson1MessageAttributeStringValues(input.StringValues, context),
        }),
    };
};
const serializeAws_restJson1Processor = (input, context) => {
    return {
        ...(input.Configuration != null && {
            Configuration: serializeAws_restJson1ProcessorConfiguration(input.Configuration, context),
        }),
        ...(input.ExecutionOrder != null && { ExecutionOrder: input.ExecutionOrder }),
        ...(input.FallbackAction != null && { FallbackAction: input.FallbackAction }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_restJson1ProcessorConfiguration = (input, context) => {
    return {
        ...(input.Lambda != null && { Lambda: serializeAws_restJson1LambdaConfiguration(input.Lambda, context) }),
    };
};
const serializeAws_restJson1ProcessorList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1Processor(entry, context);
    });
};
const serializeAws_restJson1PushNotificationConfiguration = (input, context) => {
    return {
        ...(input.Body != null && { Body: input.Body }),
        ...(input.Title != null && { Title: input.Title }),
        ...(input.Type != null && { Type: input.Type }),
    };
};
const serializeAws_restJson1PushNotificationPreferences = (input, context) => {
    return {
        ...(input.AllowNotifications != null && { AllowNotifications: input.AllowNotifications }),
        ...(input.FilterRule != null && { FilterRule: input.FilterRule }),
    };
};
const serializeAws_restJson1SearchField = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Operator != null && { Operator: input.Operator }),
        ...(input.Values != null && { Values: serializeAws_restJson1SearchFieldValues(input.Values, context) }),
    };
};
const serializeAws_restJson1SearchFields = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1SearchField(entry, context);
    });
};
const serializeAws_restJson1SearchFieldValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1Tag = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_restJson1TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1Tag(entry, context);
    });
};
const deserializeAws_restJson1AppInstanceUserMembershipSummary = (output, context) => {
    return {
        ReadMarkerTimestamp: output.ReadMarkerTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.ReadMarkerTimestamp)))
            : undefined,
        Type: (0, smithy_client_1.expectString)(output.Type),
    };
};
const deserializeAws_restJson1BatchChannelMemberships = (output, context) => {
    return {
        ChannelArn: (0, smithy_client_1.expectString)(output.ChannelArn),
        InvitedBy: output.InvitedBy != null ? deserializeAws_restJson1Identity(output.InvitedBy, context) : undefined,
        Members: output.Members != null ? deserializeAws_restJson1Members(output.Members, context) : undefined,
        Type: (0, smithy_client_1.expectString)(output.Type),
    };
};
const deserializeAws_restJson1BatchCreateChannelMembershipError = (output, context) => {
    return {
        ErrorCode: (0, smithy_client_1.expectString)(output.ErrorCode),
        ErrorMessage: (0, smithy_client_1.expectString)(output.ErrorMessage),
        MemberArn: (0, smithy_client_1.expectString)(output.MemberArn),
    };
};
const deserializeAws_restJson1BatchCreateChannelMembershipErrors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1BatchCreateChannelMembershipError(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1Channel = (output, context) => {
    return {
        ChannelArn: (0, smithy_client_1.expectString)(output.ChannelArn),
        ChannelFlowArn: (0, smithy_client_1.expectString)(output.ChannelFlowArn),
        CreatedBy: output.CreatedBy != null ? deserializeAws_restJson1Identity(output.CreatedBy, context) : undefined,
        CreatedTimestamp: output.CreatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.CreatedTimestamp)))
            : undefined,
        LastMessageTimestamp: output.LastMessageTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastMessageTimestamp)))
            : undefined,
        LastUpdatedTimestamp: output.LastUpdatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastUpdatedTimestamp)))
            : undefined,
        Metadata: (0, smithy_client_1.expectString)(output.Metadata),
        Mode: (0, smithy_client_1.expectString)(output.Mode),
        Name: (0, smithy_client_1.expectString)(output.Name),
        Privacy: (0, smithy_client_1.expectString)(output.Privacy),
    };
};
const deserializeAws_restJson1ChannelAssociatedWithFlowSummary = (output, context) => {
    return {
        ChannelArn: (0, smithy_client_1.expectString)(output.ChannelArn),
        Metadata: (0, smithy_client_1.expectString)(output.Metadata),
        Mode: (0, smithy_client_1.expectString)(output.Mode),
        Name: (0, smithy_client_1.expectString)(output.Name),
        Privacy: (0, smithy_client_1.expectString)(output.Privacy),
    };
};
const deserializeAws_restJson1ChannelAssociatedWithFlowSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ChannelAssociatedWithFlowSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ChannelBan = (output, context) => {
    return {
        ChannelArn: (0, smithy_client_1.expectString)(output.ChannelArn),
        CreatedBy: output.CreatedBy != null ? deserializeAws_restJson1Identity(output.CreatedBy, context) : undefined,
        CreatedTimestamp: output.CreatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.CreatedTimestamp)))
            : undefined,
        Member: output.Member != null ? deserializeAws_restJson1Identity(output.Member, context) : undefined,
    };
};
const deserializeAws_restJson1ChannelBanSummary = (output, context) => {
    return {
        Member: output.Member != null ? deserializeAws_restJson1Identity(output.Member, context) : undefined,
    };
};
const deserializeAws_restJson1ChannelBanSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ChannelBanSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ChannelFlow = (output, context) => {
    return {
        ChannelFlowArn: (0, smithy_client_1.expectString)(output.ChannelFlowArn),
        CreatedTimestamp: output.CreatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.CreatedTimestamp)))
            : undefined,
        LastUpdatedTimestamp: output.LastUpdatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastUpdatedTimestamp)))
            : undefined,
        Name: (0, smithy_client_1.expectString)(output.Name),
        Processors: output.Processors != null ? deserializeAws_restJson1ProcessorList(output.Processors, context) : undefined,
    };
};
const deserializeAws_restJson1ChannelFlowSummary = (output, context) => {
    return {
        ChannelFlowArn: (0, smithy_client_1.expectString)(output.ChannelFlowArn),
        Name: (0, smithy_client_1.expectString)(output.Name),
        Processors: output.Processors != null ? deserializeAws_restJson1ProcessorList(output.Processors, context) : undefined,
    };
};
const deserializeAws_restJson1ChannelFlowSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ChannelFlowSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ChannelMembership = (output, context) => {
    return {
        ChannelArn: (0, smithy_client_1.expectString)(output.ChannelArn),
        CreatedTimestamp: output.CreatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.CreatedTimestamp)))
            : undefined,
        InvitedBy: output.InvitedBy != null ? deserializeAws_restJson1Identity(output.InvitedBy, context) : undefined,
        LastUpdatedTimestamp: output.LastUpdatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastUpdatedTimestamp)))
            : undefined,
        Member: output.Member != null ? deserializeAws_restJson1Identity(output.Member, context) : undefined,
        Type: (0, smithy_client_1.expectString)(output.Type),
    };
};
const deserializeAws_restJson1ChannelMembershipForAppInstanceUserSummary = (output, context) => {
    return {
        AppInstanceUserMembershipSummary: output.AppInstanceUserMembershipSummary != null
            ? deserializeAws_restJson1AppInstanceUserMembershipSummary(output.AppInstanceUserMembershipSummary, context)
            : undefined,
        ChannelSummary: output.ChannelSummary != null
            ? deserializeAws_restJson1ChannelSummary(output.ChannelSummary, context)
            : undefined,
    };
};
const deserializeAws_restJson1ChannelMembershipForAppInstanceUserSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ChannelMembershipForAppInstanceUserSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ChannelMembershipPreferences = (output, context) => {
    return {
        PushNotifications: output.PushNotifications != null
            ? deserializeAws_restJson1PushNotificationPreferences(output.PushNotifications, context)
            : undefined,
    };
};
const deserializeAws_restJson1ChannelMembershipSummary = (output, context) => {
    return {
        Member: output.Member != null ? deserializeAws_restJson1Identity(output.Member, context) : undefined,
    };
};
const deserializeAws_restJson1ChannelMembershipSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ChannelMembershipSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ChannelMessage = (output, context) => {
    return {
        ChannelArn: (0, smithy_client_1.expectString)(output.ChannelArn),
        Content: (0, smithy_client_1.expectString)(output.Content),
        CreatedTimestamp: output.CreatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.CreatedTimestamp)))
            : undefined,
        LastEditedTimestamp: output.LastEditedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastEditedTimestamp)))
            : undefined,
        LastUpdatedTimestamp: output.LastUpdatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastUpdatedTimestamp)))
            : undefined,
        MessageAttributes: output.MessageAttributes != null
            ? deserializeAws_restJson1MessageAttributeMap(output.MessageAttributes, context)
            : undefined,
        MessageId: (0, smithy_client_1.expectString)(output.MessageId),
        Metadata: (0, smithy_client_1.expectString)(output.Metadata),
        Persistence: (0, smithy_client_1.expectString)(output.Persistence),
        Redacted: (0, smithy_client_1.expectBoolean)(output.Redacted),
        Sender: output.Sender != null ? deserializeAws_restJson1Identity(output.Sender, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1ChannelMessageStatusStructure(output.Status, context) : undefined,
        Type: (0, smithy_client_1.expectString)(output.Type),
    };
};
const deserializeAws_restJson1ChannelMessageStatusStructure = (output, context) => {
    return {
        Detail: (0, smithy_client_1.expectString)(output.Detail),
        Value: (0, smithy_client_1.expectString)(output.Value),
    };
};
const deserializeAws_restJson1ChannelMessageSummary = (output, context) => {
    return {
        Content: (0, smithy_client_1.expectString)(output.Content),
        CreatedTimestamp: output.CreatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.CreatedTimestamp)))
            : undefined,
        LastEditedTimestamp: output.LastEditedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastEditedTimestamp)))
            : undefined,
        LastUpdatedTimestamp: output.LastUpdatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastUpdatedTimestamp)))
            : undefined,
        MessageAttributes: output.MessageAttributes != null
            ? deserializeAws_restJson1MessageAttributeMap(output.MessageAttributes, context)
            : undefined,
        MessageId: (0, smithy_client_1.expectString)(output.MessageId),
        Metadata: (0, smithy_client_1.expectString)(output.Metadata),
        Redacted: (0, smithy_client_1.expectBoolean)(output.Redacted),
        Sender: output.Sender != null ? deserializeAws_restJson1Identity(output.Sender, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1ChannelMessageStatusStructure(output.Status, context) : undefined,
        Type: (0, smithy_client_1.expectString)(output.Type),
    };
};
const deserializeAws_restJson1ChannelMessageSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ChannelMessageSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ChannelModeratedByAppInstanceUserSummary = (output, context) => {
    return {
        ChannelSummary: output.ChannelSummary != null
            ? deserializeAws_restJson1ChannelSummary(output.ChannelSummary, context)
            : undefined,
    };
};
const deserializeAws_restJson1ChannelModeratedByAppInstanceUserSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ChannelModeratedByAppInstanceUserSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ChannelModerator = (output, context) => {
    return {
        ChannelArn: (0, smithy_client_1.expectString)(output.ChannelArn),
        CreatedBy: output.CreatedBy != null ? deserializeAws_restJson1Identity(output.CreatedBy, context) : undefined,
        CreatedTimestamp: output.CreatedTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.CreatedTimestamp)))
            : undefined,
        Moderator: output.Moderator != null ? deserializeAws_restJson1Identity(output.Moderator, context) : undefined,
    };
};
const deserializeAws_restJson1ChannelModeratorSummary = (output, context) => {
    return {
        Moderator: output.Moderator != null ? deserializeAws_restJson1Identity(output.Moderator, context) : undefined,
    };
};
const deserializeAws_restJson1ChannelModeratorSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ChannelModeratorSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ChannelSummary = (output, context) => {
    return {
        ChannelArn: (0, smithy_client_1.expectString)(output.ChannelArn),
        LastMessageTimestamp: output.LastMessageTimestamp != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.LastMessageTimestamp)))
            : undefined,
        Metadata: (0, smithy_client_1.expectString)(output.Metadata),
        Mode: (0, smithy_client_1.expectString)(output.Mode),
        Name: (0, smithy_client_1.expectString)(output.Name),
        Privacy: (0, smithy_client_1.expectString)(output.Privacy),
    };
};
const deserializeAws_restJson1ChannelSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ChannelSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1Identity = (output, context) => {
    return {
        Arn: (0, smithy_client_1.expectString)(output.Arn),
        Name: (0, smithy_client_1.expectString)(output.Name),
    };
};
const deserializeAws_restJson1LambdaConfiguration = (output, context) => {
    return {
        InvocationType: (0, smithy_client_1.expectString)(output.InvocationType),
        ResourceArn: (0, smithy_client_1.expectString)(output.ResourceArn),
    };
};
const deserializeAws_restJson1Members = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Identity(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1MessageAttributeMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1MessageAttributeValue(value, context),
        };
    }, {});
};
const deserializeAws_restJson1MessageAttributeStringValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_restJson1MessageAttributeValue = (output, context) => {
    return {
        StringValues: output.StringValues != null
            ? deserializeAws_restJson1MessageAttributeStringValues(output.StringValues, context)
            : undefined,
    };
};
const deserializeAws_restJson1MessagingSessionEndpoint = (output, context) => {
    return {
        Url: (0, smithy_client_1.expectString)(output.Url),
    };
};
const deserializeAws_restJson1Processor = (output, context) => {
    return {
        Configuration: output.Configuration != null
            ? deserializeAws_restJson1ProcessorConfiguration(output.Configuration, context)
            : undefined,
        ExecutionOrder: (0, smithy_client_1.expectInt32)(output.ExecutionOrder),
        FallbackAction: (0, smithy_client_1.expectString)(output.FallbackAction),
        Name: (0, smithy_client_1.expectString)(output.Name),
    };
};
const deserializeAws_restJson1ProcessorConfiguration = (output, context) => {
    return {
        Lambda: output.Lambda != null ? deserializeAws_restJson1LambdaConfiguration(output.Lambda, context) : undefined,
    };
};
const deserializeAws_restJson1ProcessorList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Processor(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1PushNotificationPreferences = (output, context) => {
    return {
        AllowNotifications: (0, smithy_client_1.expectString)(output.AllowNotifications),
        FilterRule: (0, smithy_client_1.expectString)(output.FilterRule),
    };
};
const deserializeAws_restJson1Tag = (output, context) => {
    return {
        Key: (0, smithy_client_1.expectString)(output.Key),
        Value: (0, smithy_client_1.expectString)(output.Value),
    };
};
const deserializeAws_restJson1TagList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Tag(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => {
    var _a;
    return ({
        httpStatusCode: output.statusCode,
        requestId: (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
};
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
